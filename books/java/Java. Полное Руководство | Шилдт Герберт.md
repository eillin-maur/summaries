### Объектно-ориентированное программирование:

1. Два основных элементов программ: код и данные, которые этот код обрабатывает
2. Модель, ориентированная на процессы - последовательность линейных шагов, код воздействует на данные
3. Объектно-ориентированный подход - программа организована вокруг данных (объектов) и набора определенных интерфейсов с этими данными
4. Абстракция - позволяет не задумываться о сложности объектов, вместо этого объект можно использовать как единое целое
5. Инкапсуляция - механизм связывания кода и данных, защищая оба компонента от внешнего влияния, сокрытие данных, доступ вовнутрь контролируется определенным интерфейсом
6. Java-класс как основа инкапсуляции, класс определяет структуру и поведение (данные и код) и инкапсулирует сложную структуру, объект - экземпляр класса, класс - логическое определение, объект - физическое определение
7. Данные и код как члены класса: данные - атрибуты класса, код - методы класса
8. Открытые и закрытые атрибуты и методы класса
9. Наследование - процесс, в результате которого один объект получает свойства другого объекта, обеспечивает иерархическую классификацию и определение только уникальных характеристик объекта
10. Суперклассы и подклассы
11. Связь наследования и инкапсуляции: если класс инкапсулирует определенные свойства, то любой его подкласс будет иметь те же свойства плюс его специфичные свойства
12. Полиморфизм - механизм, позволяющий использовать один и тот же интерфейс для общего класса действий, каждое действие зависит от конкретной ситуации, один интерфейс - несколько действий

### Примеры программ
1. Файл - единица компиляции, содержит определение одного или нескольких классов, расширение .java, имя файла совпадает с именем главного класса
2. javac компилятор, создает .class файл - версия байт-кода, промежуточного представления программы, содержащего инструкции для JVM
3. Загрузчик приложений: Java <имя класса>
4. Многострочные, однострочные и документирующие комментарии
5. Метод main(), вызывается перед созданием любых объектов, static, void, public
6. Параметры методов, переменные, <тип> <имя_переменной>
7. Управляющие операторы: if (условие) оператор, for(инициализация - начальное значение переменной управления циклом; условие - логическое выражение для проверки значения переменной, если истинно, то цикл работает; итерация - определяет порядок изменения переменной управления циклом на каждом шаге) оператор
8. Инкремент, декремент, префиксная и постфиксная форма
9. Группировка двух и более операторов, {}
10. Пробелы, идентификаторы, литералы, комментарии, разделители
11. Библиотеки классов
12. JRE, JDK, JVM

### Типы данных
1. Примитивные типы: byte, short, int, long, float, double, char, boolean
2. Статическая типизация, примитивы - это одиночные значения, а не сложные объекты, имеющие явный допустимый диапазон значений
3. Целые числа: byte, short, int, long - все они знаковые, отдельно беззнаковых типов нет
4. Длина целых чисел не означает объем занимаемой памяти, а диапазон допустимых значений
5. byte - 1 байт, short - 2 байта, int - 4 байта, long - 8 байт
6. Диапазон определяется как 2 в степени количества бит на тип, но с корректировкой на отрицательные числа
7. При указании значений byte, short в выражениях их тип приводится к типу int при вычислении выражения
8. Числа с плавающей точкой (действительные числа): float, double
9. float - одинарная точность, для хранения в оперативной памяти 4 байта, обработка быстрее, использует меньше памяти, но может не обеспечивать требуемую точность вычислений
10. double - двойная точность, в оперативной памяти нужно 8 байт, используется, если требуется высокая точность вычислений
11. char - хранение символов, String - не примитивный тип, это объект, формально char - это целочисленный тип
12. Символы - это юникод, занимает 2 байта, диапазон от 0 до 2^16, можно присваивать как символы, так и их юникод коды
13. boolean - хранение логических значений true или false, для условного оператора if достаточно лишь одного значения переменной, как в Python нельзя проверить int в условном операторе
14. Любое целочисленное значение является числовым литералом
15. В целочисленных литералах могут быть числа (помимо основания 10) по основанию 8 и 16
16. Восьмеричные числа обозначаются начальным нулем
17. Шестнадцатеричные числа обозначаются начальным нулем и символом "x", а цифры от 10 до 15 заменяются на буквы от A до F
18. Когда значение литерала присваивается переменной типа byte или  short, ошибки не происходит, если значение литерала находится в диапазоне допустимых значений данного типа
19. Кроме того, целочисленный литерал всегда можно присвоить переменной типа long, но, чтобы обозначить литерал придется явно указать компилятору, что значение литерала имеет этот тип, c этой целью литерал дополняется строчной или прописной буквой L
20. Целочисленные литералы можно определить и в двоичной форме, для этого перед присваиваемым значением указывается префикс ОЬ или ОБ
21. В обозначении целочисленных литералов можно также указывать один или несколько знаков подчеркивания
22. Литералы с плавающей точкой: стандартная и экспоненциальная форма
23. Экспоненциальная форма: стандартная + суффикс (E), обозначающий степень числа 10, на которую нужно домножить число стандарной части
24. По умолчанию литералам с плавающей точкой присваивается тип double, чтобы указать float нужно дополнить литерал символом F
25. Литерал double можно также явно указать символом D
26. Логические литералы не преобразуются в значения 0 или 1
27. Символы - это индексы из набора символом юникода
28. Шестнадцатеричная форма: u\0061
29. Восьмиричная форма: \ddd
30. Переменная как основная единица хранения данных
31. Объявление переменной, динамическая инициализация
32. Область видимости: что определяет и способы ее задания
33. Класс и метод как область видимости
34. Параметры метода включаются в область видимости метода
35. Область видимости как основание для инкапсуляции
36. Вложенные области видимости, во внутреннем блоке нельзя объявлять переменные с тем же именем, что и во внешнем
37. Переменные действительны только после объявления
38. Переменные создаются при входе в их область видимости и уничтожаются при выходе из нее
39. Автоматическое преобразование типов: а) оба типа совместимы, б) длина целевого тип больше чем исходного типа, - расширяющее преобразование
40. Сужающее преобразование, явное преобразование типов: (<целевой_тип>) значение
41. Усечение
42. Автоматическое приведение типов в выражениях: при вычислении выражений тип каждого операнда byte, short, char автоматически приводится к int
43. Правила приведения типов: сначала byte, short, char приводятся к int, затем если один из операндов long - тип всего выражения приводится к long, если один из операндов float - то к float, double - к double
44. Массивы - группа однотипных переменных с общим именем
45. Одномерные массивы: <тип> <имя_переменной>[]
46. Выделение памяти под массив: new <тип>[размер], элементы массива инициализируются начальными значениями: 0, false, null
47. Индексация массива с нуля
48. Инициализатор однородного массива: {1, 3, 5}, потребность в new отпадает
49. Многомерные массивы: <тип> <имя_переменной>[][]
50. При резервировании памяти под многомерный массив необходимо указать память только для первого (левого) измерения массива, а для каждого из остальных измерений массива память можно резервировать отдельно
51. Неоднородные (не регулярные) массивы
52. Инициализатор многомерного массива
53. Присваивание значений элементам массива
54. Альтернативный синтаксис объявления массивов: <тип>[] <имя_переменной>, удобно для объявления нескольких массивов одновременно

### Операции
1. 
